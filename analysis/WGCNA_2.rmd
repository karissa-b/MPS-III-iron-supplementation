---
title: "WGCNA_2"
author: "Karissa Barthelson"
date: "2024-03-07"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  autodep = TRUE,
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center", 
  out.width ="75%", 
  out.height = "75%"
)
```

```{r}
library(tidyverse)
library(magrittr)
library(readxl)

# vis
library(pander)
library(kableExtra)
library(UpSetR)
library(scales)
library(pheatmap)
library(ggpubr)
library(ggrepel)
library(ggfortify)
library(ggforce)
library(RColorBrewer)
library(colorspace)
library(igraph)
library(DOSE)
library(enrichplot)
library(patchwork)

# analysis
library(WGCNA)
library(topGO)
library(org.Dr.eg.db)
library(clusterProfiler)
library(KEGGREST)
library(msigdbr)
library(matrixStats)

theme_set(theme_classic())
options(stringsAsFactors = FALSE)
allowWGCNAThreads()  
```

# Introduction

In the previous [WGCNA analysis](WGCNA.html), I analysed all fish in the experiment together. This was overall successful, and I found modules of co-expressed genes, which were over-represented with gene ontologies meaning they have biological relevance. Some modules were significantly correlated with genotype and treatment as well. However, it was difficult to perform linear modelling when I wanted to look at module eigengenes which are associated with genotype and treatment across the sexes. I found a paper by [Sutherland et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6404618/) which performed WGCNA analysis on Brook Char (another type of fish) across sexes. They built co-expression networks for each sex, then looked for module preservation. I will try this approach here. 

# setup
## Read in data

The `DGE` object was read in, which contains the gene expression and sample info. The logCPM values for each gene were also read in which are already filtered for lowly expressed genes, are TMM & CQN normalised. I then will seperate the DGE object into two of them by sex. 
```{r}
# read in dge object (counts)
x <- readRDS("data/RNAseq/R-objects/x_dgeObject_withCQNoffset.rds")

# update the group factor for this analysis
x$samples %<>% 
  mutate(group = paste0(genotype, "_", treatment2) %>% 
           as.factor())

# CQN adjusted logCPM
logCPM <- readRDS("data/RNAseq/R-objects/logCPM_CQN")

```

WGCNA requires normalised data - so this is ok for input. 

```{r, fig.cap="LogCPM values after TMM and CQN normalisation. All samples appear to have similar distributions"}
# plot the TMM/CQN normalised data 
logCPM %>% 
  as.data.frame() %>% 
  rownames_to_column("gene_id") %>% 
  pivot_longer(
    names_to = "sample", 
    values_to = "logCPM", 
    colnames(x)
  ) %>% 
  left_join(x$samples) %>% 
  ggplot(
    aes(x = sample, y = logCPM, 
        fill = genotype), 
    size = 1
    ) +
  geom_boxplot()+
  facet_wrap(~sex+treatment, scales = "free_x", 
             nrow = 1) +
  theme(
    axis.text.x = element_text(angle = -45, hjust = 0))
```

```{r}
# make vectors for subsetting
male.fish.ids <- x$samples %>% 
  dplyr::filter(sex == "male") %>% 
  .$fish_id

female.fish.ids <- x$samples %>% 
  dplyr::filter(sex == "female") %>% 
  .$fish_id

# subset DGEs
x.males <- x[,male.fish.ids]
x.females <- x[,female.fish.ids]

# subset logCPMs
logCPM.male <- logCPM[,male.fish.ids]
logCPM.female <- logCPM[,female.fish.ids]
```

## prepare for WGCNA

Genes that do not vary across samples are not informative in network analysis, and will increase the noise. So I will only retain the top 75% most variable genes in the datasets. Assessment of the distribution of the gene expression values before and after filtering shows no issues in any artefacts being generated. 

```{r}
# Retain genes with sufficiently high variation in expression across all samples.
# Here we define sufficiently high variation as having a standard deviation above the 25th quantile (so not in bottom 25%).
variableGenes.female <- rowSds(logCPM.female) >  quantile(rowSds(logCPM.female), 0.25)

variableGenes.male <- rowSds(logCPM.male) >  quantile(rowSds(logCPM.male), 0.25)
```

```{r}
# write a function to plot these out
plot.density.filtering = function(dge, 
                                  logCPM, 
                                  variableGenesVector, 
                                  ggtitle) {
  logCPM %>% 
  as.data.frame() %>% 
  rownames_to_column("gene_id") %>%
  pivot_longer(
    names_to = "fish_id", 
    values_to = "logCPM", 
    colnames(dge)
  ) %>% 
  left_join(dge$samples) %>% 
  ggplot(aes(x = logCPM, colour = group)) +
  geom_density() + 
  ggtitle(ggtitle)
}
```

```{r, fig.cap="Females"}
## females
ggarrange(
  plot.density.filtering(
    dge = x.females, logCPM = logCPM.female, ggtitle = "Before filtering"), 
  
    plot.density.filtering(
    dge = x.females, 
    logCPM = logCPM.female %>% extract(variableGenes.female,),
    ggtitle = "After filtering"), 
  common.legend = TRUE
)
```

```{r, fig.cap="Males"}
ggarrange(
  plot.density.filtering(
    dge = x.males, logCPM = logCPM.male, ggtitle = "Before filtering"), 
  
    plot.density.filtering(
    dge = x.males, 
    logCPM = logCPM.male %>% extract(variableGenes.male,),
    ggtitle = "After filtering"), 
  common.legend = TRUE
) 
```

```{r}
# peform the filtering
logCPM.female.filtered <- logCPM.female %>% extract(variableGenes.female,)
logCPM.male.filtered <- logCPM.male %>% extract(variableGenes.male,)
```

the table below shows the number of genes retained after filtering. While the numbers of genes are the same in each sex, they are not necessarily the same genes 

```{r}
tibble(
  `filtered?` = c(
    "unfiltered","filtered" 
), 
n_genes = c(
  dim(logCPM.female)[1], 

  dim(logCPM.male.filtered)[1]
  )
) %>% 
  pander()
```

The WGCNA pipeline is expecting an input matrix of RNAseq data (counts). Usually we need to rotate (transpose) the input data so `rows = samples` and `columns = gene counts`. So this is done here. 

```{r}
# transpose the data 
input_mat.females = t(logCPM.female.filtered)
input_mat.males = t(logCPM.male.filtered)
```

# check sample clustering

Here we use the gene expression patterns after normalisation to build 
sample dendrograms (sample tree), and check how the `traits` (e.g.
metadata) related to the sample dendrogram.

Traits uses a design matrix as described in the previous DE genes
analysis.s
```{r, fig.cap="No obvious outliers are observed here"}
# Apply hierarchial clustering to the gene exp data. 
sampleTree.females <- hclust(dist(input_mat.females), method = "complete")
sampleTree.males <- hclust(dist(input_mat.males), method = "complete")

# Using the design matrix, which contains information of samples' sex and genotype
traits.females <-  
  model.matrix(~(genotype+treatment)^2, x.females$samples) %>%
  as.data.frame

traits.males <-  
  model.matrix(~(genotype+treatment)^2, x.males$samples) %>%
  as.data.frame

# Assign each group in design matrix to a colour. 
traitColors.females <- 
  numbers2colors(traits.females, 
                 signed = FALSE, 
                 colors = c("#ffffff", "#73626E"))

traitColors.males <- 
  numbers2colors(traits.males, 
                 signed = FALSE, 
                 colors = c("#ffffff", "#73626E"))

# Plot dendrogram of clustered samples with the design matrix underneath. 

plotDendroAndColors(
  sampleTree.females, 
  traitColors.females,
  groupLabels = names(traits.females),
  main = "Females \nSample dendrogram and trait heatmap",
  marAll = c(3,15,5,0)
  )

plotDendroAndColors(
  sampleTree.males, 
  colors = traitColors.males,
  groupLabels = names(traits.males),
  main = "Males\nSample dendrogram and trait heatmap", 
  marAll = c(3,15,5,0)
  )
```



# Network construction

## Choice of soft-thresholding power

Constructing a weighted gene network requires a soft-thresholding power Î², which will be chosen based on the scale-free topology criterion described by Zhang & Horvath (2005). 
Here we perform the analysis of network topology for choosing a proper soft-threshold power.The following plots show the sufficiently high scale-free topology index (R2). Zhang and Hovarth stated in their framework ref that "we use the first parameter value where saturation is reached as long as it is above 0.8". Also, the mean connectivity should be not 0, otherwise nothing will be connected.

Also, I will need to choose between a signed or unsigned network. A good explanation of signed vs unsigned networks is described
[here](https://peterlangfelder.com/2019/05/30/signed-network-from-signed-topological-overlap/). However, essentially, in an *unsigned* network, genes are considered connected regardless of whether the correlation is positive or negative. Then in signed networks, the direction matters. I will prepare a signed network, as I think directionality is important. 

```{r}
# prepare a vector with a series of candicdate poweres
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# signed network analysis of scale-free topology
sft.females <- 
  pickSoftThreshold(
    input_mat.females, #  Input data 
    powerVector = powers, 
    networkType = "signed",
    dataIsExpr = TRUE, 
    verbose = 5
  )

sft.males <- 
  pickSoftThreshold(
    input_mat.males, #  Input data 
    powerVector = powers, 
    networkType = "signed",
    dataIsExpr = TRUE, 
    verbose = 5
  )
```

```{r}
# plot out the results
# first define the function. 
plot.powers = function(sft) {
  
  ggarrange(
     sft$fitIndices %>% 
    ggplot(
      aes(x = Power, y = -sign(slope) * SFT.R.sq)
    ) +
    geom_label(
      aes(label = Power)
    ) +
    geom_hline(
      yintercept = 0.8, 
      colour = "red") +
    annotate(
      geom = "text", 
      label = "beta = 0.8",
      colour = "red",
      x = 4, 
      y = 0.75
    ) +
    labs(
      x = "Soft Threshold (power)",
      y = "Scale Free Topology Model Fit, signed R^2",
      title = "Scale independence"
    ), 
  
  sft$fitIndices %>% 
    ggplot(
      aes(x = Power, y = mean.k.)
    ) +
    geom_label(
      aes(label = Power)
    ) +
    geom_hline(
      yintercept = 0, 
      colour = "red") +
    annotate(
      geom = "text", 
      label = "k = 0",
      colour = "red",
      x = 3, 
      y = 190
    ) +
    labs(
      x = "Soft Threshold (power)",
      y = "Mean connectivity (k)",
      title = "Mean connectivity" 
  ) 
  
)
  
}

plot.powers(sft = sft.males) 

plot.powers(sft = sft.females)
```

### define soft powers
```{r}
softpower.signed = 16
```

From the 2 graphs, I will assign the soft powers for the signed networks as `r softpower.signed`. This is the first value where the graphs plateau which is
more than 0.8.

## Co-expression adjacency

We now calculate the adjacency matrix, using the soft thresholding powers just described. This essentially takes the gene expression data and calculates the pairwise similarity between genes (Pearson correlation). This similarity measure is then transformed into an adjacency
matrix by using the power function. (i.e. a = \|s\^Î²\|)

```{r}
adjacency.signed.females <-
  adjacency(
    input_mat.females, 
    type = "signed", 
    power = softpower.signed, 
    )

adjacency.signed.males <-
  adjacency(
    input_mat.males, 
    type = "signed", 
    power = softpower.signed
    )
```

## Topological Overlap Matrix (TOM)

To minimize effects of noise and spurious associations, we transform the adjacency into Topological Overlap Matrix, and calculate the corresponding dissimilarity.

```{r}
# Turn adjacency into topological overlap
TOM.signed.males <- TOMsimilarity(adjacency.signed.males)
TOM.signed.females <- TOMsimilarity(adjacency.signed.females)

dissTOM.signed.males = 1-TOM.signed.males
dissTOM.signed.females = 1-TOM.signed.females
```

Plotting the dissimilarity of the genes in the network reveals a lot of the genes with TOM between 0.9 and 1. This means that the majority of the genes are very similar to each other. 

```{r}
# We now use hierarchial clustering to produce a hierarchial clustering tree (dendrogram) of genes using TOM
geneTree.signed.males <- 
  hclust(as.dist(dissTOM.signed.males), method = "average")
geneTree.signed.females <- 
  hclust(as.dist(dissTOM.signed.females), method = "average")

dev.off()
par(mfrow=c(2,1))

# Plot the dendrogram
plot(geneTree.signed.males,
     xlab = "", ylab = "", 
     main = "Gene clustering on TOM-based dissimilarity\nMale network",
     labels = FALSE, hang = 0.04)

plot(geneTree.signed.females,
     xlab = "", ylab = "", 
     main = "Female network",
     labels = FALSE, hang = 0.04)
```

# Define modules

The next step is to define the modules or clusters of genes. This is done using dynamic tree cut method.

```{r}
# The authors of WGCNA suggest this minimum module size to give "relatively large modules"
minModuleSize = 30

# Module identification using dynamic tree cut. The [arameters are set according to what the WGCNA tutorial suggests. 
dynamicMods.signed.males <- 
  cutreeDynamic(
    dendro = geneTree.signed.males, 
    distM = dissTOM.signed.males,
    
    method = "hybrid",
    deepSplit = 2, 
    pamStage = TRUE,
    pamRespectsDendro = FALSE,
    minClusterSize = minModuleSize
    )

dynamicMods.signed.females <- 
  cutreeDynamic(
    dendro = geneTree.signed.females, 
    distM = dissTOM.signed.females,
    
    method = "hybrid",
    deepSplit = 2, 
    pamStage = TRUE,
    pamRespectsDendro = FALSE,
    minClusterSize = minModuleSize)

# give the modules a name based off baseR colours. 
dynamicColors.signed.females <- labels2colors(dynamicMods.signed.females)
dynamicColors.signed.males <- labels2colors(dynamicMods.signed.males)
```

## raw modules
```{r}
plot_n_genes_perModule = function(dynamicColors, title) {
  dynamicColors %>%
    as.data.frame() %>% 
    set_colnames("mod") %>% 
    group_by(mod) %>% 
    mutate(total = n()) %>% 
    ggplot(aes(x = reorder(mod, -total), fill = mod)) +
    geom_bar(colour= "black")  +
    theme(
      axis.text.x = element_text(
        angle = -90, hjust = 0, vjust = 0.4
      ),
      plot.title = element_text(hjust = 0.5, face = "bold"),
      legend.position = "none"
    ) +
    labs(
      title = title, 
      x = "Module", 
      y = "Number of genes"
    ) +
  scale_fill_identity() # fill the actual colours
}

plot_n_genes_perModule(dynamicColors = dynamicColors.signed.females, 
                       title = "Female modules before merging")

plot_n_genes_perModule(dynamicColors = dynamicColors.signed.males, 
                       title = "Male modules before merging")
```

The next plot shows the clustering dendrogram of genes, with dissimilarity based on topological overlap, together with assigned merged module colors. There are a lot of modules here which are all over the dendrogram. The plots i've seen previously (i.e. [here](https://www.google.com/search?q=wgcna+dendrogram&sca_esv=592686156&rlz=1C5CHFA_enAU758AU758&tbm=isch&sxsrf=AM9HkKkSBZcwsy5iPy7CeFt2oRp73UiS6A:1703121651127&source=lnms&sa=X&sqi=2&ved=2ahUKEwj675jIrp-DAxU6TGwGHfCTBwMQ_AUoAXoECAIQAw&biw=1239&bih=827&dpr=1#imgrc=FAA689FFNIDKNM)) often show at least some blocks of module colours on the dendrogram. Although this is not always the case (see [here](https://peterlangfelder.com/2018/12/30/why-wgcna-modules-dont-always-agree-with-the-dendrogram/)), as this can be a limitation of visualizing on a dendrogram.

```{r}
plotDendroAndColors(geneTree.signed.males, 
                    dynamicColors.signed.males, 
                    "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors\nsigned network"
)

plotDendroAndColors(geneTree.signed.females, 
                    dynamicColors.signed.females, 
                    "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors\nsigned network"
)
```

## merge similar modules

The Dynamic Tree Cut may identify modules whose expression profiles are very similar. It may be beneficial to merge such modules since their genes are highly co-expressed. To quantify co-expression similarity of entire modules, we calculate their eigengenes and cluster them on their correlation.

```{r}
# calculate the eigengenes of each module
MEList.signed.females <- 
  moduleEigengenes(
    expr = logCPM.female.filtered %>% t(), 
    colors = dynamicColors.signed.females,
    excludeGrey = TRUE
  )

MEList.signed.males <- 
  moduleEigengenes(
    expr = logCPM.male.filtered %>% t(), 
    colors = dynamicColors.signed.males,
    excludeGrey = TRUE
  )


# Calculate dissimilarity of module eigengenes
MEDiss.signed.females = 1-cor(MEList.signed.females$eigengenes)
MEDiss.signed.males = 1-cor(MEList.signed.males$eigengenes)


# Cluster module eigengenes
METree.signed.females = hclust(as.dist(MEDiss.signed.females), method = "average")
METree.signed.males = hclust(as.dist(MEDiss.signed.males), method = "average")

# Plot the result
sizeGrWindow(7, 6)
plot(METree.signed.females, 
     main = "Clustering of module eigengenes\n Females",
     xlab = "", sub = "")

plot(METree.signed.males, 
     main = "Clustering of module eigengenes\n Males",
     xlab = "", sub = "")

# defnine a module threshold as the same if it has more than 25% dissimilarity (i.e.. 75% similar)
MEDissThres = 0.25
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red") 
```

There appear to be plenty of modules which show similarity. Here we
define the threshold for module merging as a height \< 0.25 (as
performed by authors of WGCNA). This corresponds to correlation of 0.75,
to merge. 

```{r}
# Call an automatic merging function
merge.signed.females <- mergeCloseModules(
  t(logCPM.female.filtered), 
  dynamicColors.signed.females, 
  cutHeight = MEDissThres, 
  verbose = 3)

merge.signed.males <- mergeCloseModules(
  t(logCPM.male.filtered), 
  dynamicColors.signed.males, 
  cutHeight = MEDissThres, 
  verbose = 3)


# The merged module colors
mergedColors.signed.males = merge.signed.males$colors
mergedColors.signed.females = merge.signed.females$colors


# Table of number of modules after merging

plot_n_genes_perModule(dynamicColors = merge.signed.males$colors, 
                       title = "Males")
plot_n_genes_perModule(dynamicColors = merge.signed.females$colors, 
                       title = "females")


# Cluster module eigengenes
mergedMETree.signed.females = hclust(as.dist(MEDiss.signed.females), method = "average")

mergedMETree.signed.males = hclust(as.dist(MEDiss.signed.males), method = "average")
```

## gene tree after merging similar modules
```{r, fig.cap="female brains"}
sizeGrWindow(12, 9)
plotDendroAndColors(
  geneTree.signed.females, 
  cbind(mergedColors.signed.females),
  "Modules",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```


```{r, fig.cap="male brains"}
plotDendroAndColors(
  geneTree.signed.males, 
  merge.signed.males$colors,
  "Modules",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```

## change colour names

For simplicity, I want to match the module names of the male dataset to the females. This is done with the `WGCNA::matchLabels()` function. 

Im not sure this completely worked. But will try sorting this out later. 

```{r}
# males 
new.module.labels <- 
  WGCNA::matchLabels(
    merge.signed.males$colors, 
    reference =  mergedColors.signed.females, 
    pThreshold = 0.05, extraLabels = standardColors()
    ) 

# have a look at what the above funcyion did. 
plotDendroAndColors(
  geneTree.signed.males, 
  cbind(new.module.labels, merge.signed.males$colors),
  c("Male Modules", "old male module labels"),
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)

# now update the merge names 
male.mod.conversion <- tibble(
  new = new.module.labels[,1], old = merge.signed.males$colors
  ) 

merge.signed.males$colors <-  new.module.labels[,1]

colnames(merge.signed.males$newMEs) <- tibble(old = colnames(merge.signed.males$newMEs)) %>% 
  mutate(
    old = str_remove_all(old, pattern = "ME")) %>% 
  left_join(
    male.mod.conversion %>% unique
  ) %>% 
  .$new
```


# enrichment analysis of modules

I next will perform GO enrichment analysis on the merged modules to see
if they have any biological meaning. I will do this using GO terms, as these have very specific or broad meaning. Since I am having trouble using the inbuilt functions in `WGCNA`, I will use `clusterprofiler` which allows me to perform a Fishers exact test for over representation.

## Prepare gene sets

The gene sets I will use here are KEGG, GO, cell type markers and IRE genes
```{r}
### KEGG from API
# obtain a list of genes and pathways from KEGGREST API
dr_path_entrezgene  <- keggLink("pathway", "dre") %>%
  tibble(pathway = ., eg = sub("dre:", "", names(.)))

# Use org.Dr.eg.db to obtain the conversion of entrez to ensembl
dr_kegg_anno <- dr_path_entrezgene %>%
  mutate(
    symbol = mapIds(org.Dr.eg.db, eg, "SYMBOL", "ENTREZID"),
    ensembl = mapIds(org.Dr.eg.db, eg, "ENSEMBL", "ENTREZID")
  )
# obtain the pathway names
dr_pathways <-
  keggList("pathway", "dre") %>%
  tibble(pathway = names(.), description = .)

dr_kegg_anno %<>%
  mutate(pathway = str_remove(pathway, pattern = "path:")) %>%
  left_join(dr_pathways) %>%
  dplyr::select(-eg) %>%
  dplyr::filter(ensembl %in% rownames(x)) %>%
  mutate(description = str_remove_all(description, pattern = " - Danio rerio \\(zebrafish\\)"))

# keep this table if needed
KEGG_table <- dr_kegg_anno %>%
  split(f = .$description)

# make the KEGG object for gene set testing
KEGG <- dr_kegg_anno %>%
  na.omit %>%
  distinct(pathway, ensembl, .keep_all = TRUE) %>%
  split(f = .$description) %>%
  lapply(function(x) {x$ensembl %>% unname()})


# GO Terms
goSummaries <- url("https://uofabioinformaticshub.github.io/summaries2GO/data/goSummaries.RDS") %>%
  readRDS() %>%
  mutate(
    Term = Term(id),
    gs_name = Term %>% str_to_upper() %>% str_replace_all("[ -]", "_"),
    gs_name = paste0("GO_", gs_name)
    )

minPath <- 3

GO_table <-
  msigdbr("Danio rerio", category = "C5") %>%
  dplyr::filter(grepl(gs_name, pattern = "^GO")) %>%
  left_join(x$genes, by = c("ensembl_gene" = "gene_id")) %>%
  dplyr::filter(ensembl_gene %in% rownames(x)) %>%
  mutate(
    gs_name = str_replace(gs_name,
                          pattern = "GOBP_",
                          replacement = "GO_")
    ) %>%
  mutate(
    gs_name = str_replace(gs_name,
                          pattern = "GOMF_",
                          replacement = "GO_")
    ) %>%
  mutate(
    gs_name = str_replace(gs_name,
                          pattern = "GOCC_",
                          replacement = "GO_")
    ) %>%
  left_join(goSummaries) %>%
  dplyr::filter(shortest_path >= minPath) %>%
  distinct(gs_name, ensembl_gene, .keep_all = TRUE)

# cell types
cell_type_markers.table <-
  read_xlsx("data/RNAseq/gene_sets/Suppdata2_jiangetal_2021_fcelldev.xlsx", sheet = "Brain") %>%
  dplyr::rename("gene_name" = gene) %>%
  left_join(x$genes) %>%
  dplyr::filter(gene_id %in% rownames(x))

cell_type_markers <- cell_type_markers.table %>%
  split(f = .$`cell type`) %>%
  lapply(extract2, "gene_id")


cell_type_markers %<>%
  lapply(function(y) {
    y[y %in% rownames(x)]
  })

ire <- read_rds("data/RNAseq/gene_sets/zebrafishIreGenes.rds") %>%
  lapply(function(y) {
    y %>%
      as.data.frame() %>%
      set_colnames("temp") %>%
      dplyr::filter(temp %in% rownames(x)) %>%
      .$temp
  })
```

```{r}
enrichment.table.all <- dr_kegg_anno %>%
  dplyr::select(
    term = description, gene = ensembl
  ) %>%
  mutate(term  = paste0("KEGG_", term)) %>% 
  bind_rows(
    GO_table %>%
      dplyr::select(
        term = gs_name, gene = ensembl_gene
      )
  ) %>%
  bind_rows(
    cell_type_markers.table %>%
      dplyr::select(
        term = `cell type`, gene = gene_id
  ) %>% 
    mutate(term  = paste0("CELL_", term))
  ) %>%
  bind_rows(
    read_rds("data/RNAseq/gene_sets/zebrafishIreGenes.rds") %>%
      unlist2() %>%
      tibble(
        gene = .,
        term = names(.)
   ) 
  )



```



```{r}
# Make a list with the gene expression by module 
colour.names.signed.males <- merge.signed.males$colors %>% 
  unique
colour.names.signed.females <- merge.signed.females$colors %>% 
  unique

genesInModuleList.signed.males <- 
 colour.names.signed.males %>% 
  sapply(function(x) {
    logCPM.male.filtered[mergedColors.signed.males==x,] %>% 
      rownames
  }, simplify = F)

genesInModuleList.signed.females <- 
 colour.names.signed.females %>% 
  sapply(function(x) {
    logCPM.female.filtered[mergedColors.signed.females==x,] %>% 
      rownames
  }, simplify = F)


# a function for running GO analysis

run.mod.enrichment = function(input.gene.list, genesets.table) {
  
  input.gene.list %>%
    sapply(function(y) {
      enricher(
        gene = y,
        universe = rownames(logCPM.female.filtered),
        TERM2GENE = genesets.table,
        pAdjustMethod = "fdr",
        qvalueCutoff = 0.05,
        )
  }, simplify = F)

}
```

### GO terms only
```{r}
# perform the enrichment test on GO terms
# this will take a while. 
merged.moduls.male.signed.enrichment.res <-
  genesInModuleList.signed.males %>%
  sapply(function(y) {
    enrichGO(
      gene = y,
      universe = rownames(logCPM.male.filtered),
      OrgDb = org.Dr.eg.db,
      keyType = "ENSEMBL",
      ont = "ALL",
      pAdjustMethod = "BH",
      pvalueCutoff  = 0.01,
      qvalueCutoff  = 0.05,
      readable = TRUE)
}, simplify = F)

# save this out and re-import for quick knitting 
# if any params are changed, this step needs to be re-run

#saveRDS(merged.moduls.male.signed.enrichment.res, "output/WGCNA/R_objects/merged.moduls.male.signed.enrichment.res.rds")

# read it back in 
merged.moduls.male.signed.enrichment.res.GO <-
  read_rds("output/WGCNA/R_objects/merged.moduls.male.signed.enrichment.res.rds")

# repeat for the female enrichment res.
# merged.moduls.female.signed.enrichment.res <-
#   genesInModuleList.signed.females %>%
#   sapply(function(y) {
#       enrichGO(
#         gene = y,
#         universe = rownames(logCPM.female.filtered),
#         OrgDb = org.Dr.eg.db,
#         keyType = "ENSEMBL",
#         ont = "ALL",
#         pAdjustMethod = "BH",
#         pvalueCutoff  = 0.01,
#         qvalueCutoff  = 0.05,
#         readable = TRUE)
#   }, simplify = F)

# saveRDS(merged.moduls.female.signed.enrichment.res,
#         "output/WGCNA/R_objects/merged.moduls.female.signed.enrichment.res.rds")
merged.moduls.female.signed.enrichment.res <-
  read_rds("output/WGCNA/R_objects/merged.moduls.female.signed.enrichment.res.rds")


```
### KEGG

```{r}

# enrich KEGG gene sets 
merged.moduls.female.signed.enrichment.res.KEGG <-
  run.mod.enrichment(
    input.gene.list = genesInModuleList.signed.females, 
    genesets.table =  dr_kegg_anno %>% 
      dplyr::select(term = description, gene = ensembl)
  )
  
  
merged.moduls.male.signed.enrichment.res.KEGG <-
  run.mod.enrichment(
    input.gene.list = genesInModuleList.signed.males, 
    genesets.table =  dr_kegg_anno %>% 
      dplyr::select(term = description, gene = ensembl)
  )

# prepare a list with all the results in tibble format for ease of use. 
merged.modules.signed.enrichment.tables.KEGG <- 
  list(
    females = merged.moduls.female.signed.enrichment.res.KEGG %>% 
      lapply(function(x) {
        x %>% 
          as_tibble 
      }) %>% 
      imap(~ .x %>% mutate(module = .y)), # add mod name from list element name
    
    males = merged.moduls.male.signed.enrichment.res.KEGG %>% 
      lapply(function(x) {
        x %>% 
          as_tibble 
      }) %>% 
  imap(~ .x %>% mutate(module = .y))
  )

```


### Cell types

```{r}

# enrich cell type gene sets 
merged.moduls.female.signed.enrichment.res.CELL <- 
  run.mod.enrichment(
    input.gene.list = genesInModuleList.signed.females, 
    genesets.table =  cell_type_markers.table %>% 
      dplyr::select(term = `cell type`, gene = gene_id)
  )
  

merged.moduls.male.signed.enrichment.res.CELL <-
  run.mod.enrichment(
    input.gene.list = genesInModuleList.signed.males, 
    genesets.table =  cell_type_markers.table %>% 
      dplyr::select(term = `cell type`, gene = gene_id)
  )
  


# prepare a list with all the results in tibble format for ease of use. 
merged.modules.signed.enrichment.tables.CELL <- 
  list(
    females = merged.moduls.female.signed.enrichment.res.CELL %>% 
      lapply(function(x) {
        x %>% 
          as_tibble 
      }) %>% 
      imap(~ .x %>% mutate(module = .y)), # add mod name from list element name
    
    males = merged.moduls.male.signed.enrichment.res.CELL %>% 
      lapply(function(x) {
        x %>% 
          as_tibble 
      }) %>% 
  imap(~ .x %>% mutate(module = .y))
  )
```

### all gene sets
```{r}
# enrich KEGG, GO, IRE and cell type gene sets 
merged.moduls.female.signed.enrichment.res.all <-
  genesInModuleList.signed.females %>%
    sapply(function(y) {
      enricher(
        gene = y,
        universe = rownames(logCPM.female.filtered),
        TERM2GENE = enrichment.table.all,
        pAdjustMethod = "fdr",
        qvalueCutoff = 0.05,
        )
  }, simplify = F)

merged.moduls.male.signed.enrichment.res.all <-
  genesInModuleList.signed.males %>%
    sapply(function(y) {
      enricher(
        gene = y,
        universe = rownames(logCPM.male.filtered),
        TERM2GENE = enrichment.table.all,
        pAdjustMethod = "fdr",
        qvalueCutoff = 0.05,
        )
  }, simplify = F)


# prepare a list with all the results in tibble format for ease of use. 
merged.modules.signed.enrichment.tables.allGS <- 
  list(
    females = merged.moduls.female.signed.enrichment.res.all %>% 
      lapply(function(x) {
        x %>% 
          as_tibble 
      }) %>% 
      imap(~ .x %>% mutate(module = .y)), # add mod name from list element name
    
    males = merged.moduls.male.signed.enrichment.res.all %>% 
      lapply(function(x) {
        x %>% 
          as_tibble 
      }) %>% 
  imap(~ .x %>% mutate(module = .y))
  )

```

Out of the `r length(unique(mergedColors.signed.females))` modules detected in the female modules, `r sum(sapply(merged.modules.signed.enrichment.tables.allGS$females, nrow) == 0)` do not have any gene sets significantly over-represented. 

```{r}
tibble(module = unique(mergedColors.signed.females)) %>% 
  left_join(merged.modules.signed.enrichment.tables.allGS$females %>% bind_rows()) %>% 
  ggplot(aes(y = module, x = -log10(p.adjust))) +
  geom_col(
    aes(fill = module), 
    ) +
  geom_text(aes(label = Description), 
             x = 400,
             fill = NA,
             data = . %>% 
               dplyr::distinct(module, .keep_all = TRUE) ) +
  scale_fill_identity() +
  theme_bw() +
  ggtitle("Module over-representation of GO terms in females")
```

Out of the `r length(unique(mergedColors.signed.males))` modules detected in the female modules, `r sum(sapply(merged.modules.signed.enrichment.tables.allGS$males, nrow) == 0)` do not have any GO terms significantly over-represented. 

```{r}
tibble(module = unique(mergedColors.signed.males)) %>% 
  left_join(merged.modules.signed.enrichment.tables.allGS$males %>% bind_rows()) %>% 
  ggplot(aes(y = module, x = -log10(p.adjust))) +
  geom_col(
    aes(fill = module), 
    ) +
  geom_text(aes(label = Description), 
             x = 600,
             fill = NA,
             data = . %>% 
               dplyr::distinct(module, .keep_all = TRUE) ) +
  scale_fill_identity() +
  theme_bw() +
  ggtitle("Module over-representation of GO terms in males")
```

# Relate modules to fish metadata

I now want to see which modules are related to the fish metadata (i.e. for now, genotype and treatment). For this, I will correlate the merged module eigengenes with the traits of interest using Spearman corelation. 

```{r}
# Define numbers of genes and samples
nGenes <- nrow(logCPM.male.filtered)
nSamples.males <- ncol(logCPM.male.filtered)
nSamples.females <- ncol(logCPM.female.filtered)

# correlate the module eigengenes with the design matrix
moduleTraitCor.signed.males <- 
  cor(merge.signed.males$newMEs, traits.males, use = "p", method = "spearman")

moduleTraitCor.signed.females <- 
  cor(merge.signed.females$newMEs, traits.females, use = "p", method = "spearman")

# calculate the pvals
moduleTraitPValue.signed.males <- 
  corPvalueStudent(moduleTraitCor.signed.males, nSamples.males) %>%
  as.data.frame() %>%
  mutate(module = rownames(.))

moduleTraitPValue.signed.females <- 
  corPvalueStudent(moduleTraitCor.signed.females, nSamples.females) %>%
  as.data.frame() %>%
  mutate(module = rownames(.))


# define some interesting modules for plotting. 
interesting.modules.males  <-
  moduleTraitPValue.signed.males %>%
  dplyr::filter_all(any_vars(. < 0.1)) %>%
  rownames()

interesting.modules.females  <-
  moduleTraitPValue.signed.females %>%
  dplyr::filter_all(any_vars(. < 0.1)) %>%
  rownames()
```

## Females
In females,some modules are highly correlated with genotype, and less correlated in genotype x treatment, suggesting a rescue. 
```{r}
# plot a heatmap showing the correlations
moduleTraitCor.signed.females %>%
  .[interesting.modules.females,] %>%
  as.data.frame() %>%
  dplyr::select(-1) %>%
  t %>% 
  pheatmap(
    color = colorRampPalette(rev(brewer.pal(n = 7,
                                            name = "RdBu")))(100),
     border_color = "white",
     #angle_col = 90,
     treeheight_row = 0,
     treeheight_col = 0,
     clustering_distance_cols = "correlation",

     cluster_rows = FALSE,
     number_color = "black",
     cellwidth = 30, cellheight = 30,
     fontsize = 12, legend = F,
     main = "Module - trait relationships - Females",
    display_numbers = moduleTraitPValue.signed.females %>%
      .[interesting.modules.females,] %>%
      dplyr::select(-1, -module) %>%
      t %>%
      signif(1)
  )
```

## plot the module eigengenes

The eigengenes which show a significant correlation in at least one of the coefs are plotted below by genotype and treatent. The `blue`, `darkgrey` and `royalblue`   modules look interesting may be at least trending towards therapeutic.  

```{r}
# plotting MEs from interesting modules
merge.signed.females$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
   dplyr::select(fish_id, interesting.modules.females) %>% 
  as_tibble %>% 
  left_join(x.females$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot() +
  facet_wrap(~module, nrow = 2)
```

```{r}
# a function for plotting ME and upset plot
plotMEandUpset = function(ME.name, module.name) {

  plot1 <-  merge.signed.females$newMEs %>% 
    as.data.frame() %>% 
    rownames_to_column("fish_id") %>% 
    dplyr::select(fish_id, ME.name) %>% 
    as_tibble %>% 
    left_join(x.females$samples) %>% 
    pivot_longer(names_to = "module", 
                 values_to = "ME_value", 
                 starts_with("ME")) %>% 
    ggplot(
      aes(x = treatment, y = ME_value, colour = genotype)
    ) +
    geom_boxplot() +
    scale_color_manual(
      values = c("grey30", "orange")
    ) +  
    labs(
      title = paste0(module.name, " module - ", 
                     length(genesInModuleList.signed.females[[module.name]]), 
                     " genes"),
      subtitle = paste("Genotype: p =", 
                       moduleTraitPValue.signed.females[ME.name,"genotypehom"] %>% 
                         signif(2), 
                       "\nGenotype x treatment: p = ", 
                       moduleTraitPValue.signed.females[ME.name,"genotypehom:treatment10 Âµg Fe-citrate"] %>% signif(2)
      )
    )
  
  # Initialize plot2 to NULL
  plot2 <- NULL
  
   # Debugging output
  print("Checking if module.name is not empty")
  print(c("Number of enriched genesets", 
         merged.moduls.female.signed.enrichment.res.all[module.name] %>%
      as.data.frame() %>% 
      dim %>% 
      .[1]
  ))
  
  # Check if module.name is empty before plotting the second plot
  if (merged.moduls.female.signed.enrichment.res.all[module.name] %>%
      as.data.frame() %>% 
      dim %>% 
      .[1] > 1) 
  {
    plot2 <- enrichplot::upsetplot(
     merged.moduls.female.signed.enrichment.res.all[[module.name]]
    ) +
      ggtitle(paste0("Enriched GO terms in ", module.name, " module"))
    
    # Debugging output
    print("Second plot created")
  } else {
    # Debugging output
    print("Second plot not created because module.name is empty")
  }
  
  # Check if plot2 is NULL and arrange plots accordingly
  if (!is.null(plot2)) {
    ggarrange(plot1, plot2)
  } else {
    print("only plot 1 is found")
    plot1
  }
}

# test ths function
#plotMEandUpset(ME.name = "MEblue", module.name = "blue")
```


```{r}
# recursively make plot objects for the genesets which have significant associations with genotype 
# obtain the significant eigengene names
interesting.modules.females  <-
  moduleTraitPValue.signed.females %>%
  dplyr::filter_all(any_vars(. < 0.1)) %>%
  rownames()

# make the plots
plots.females <- interesting.modules.females %>% 
  sapply(function(x) {
      plotMEandUpset(ME.name = x, module.name = str_remove(x, pattern = "ME")) 
  }, simplify = F)


```


```{r}
# print the plots
plots.females$MEdarkorange2

plots.females$MEdarkslateblue

plots.females$MEblack

plots.females$MEcoral1

plots.females$MEroyalblue

plots.females$MEthistle1

plots.females$MEpalevioletred3

plots.females$MEyellow4

plots.females$MEdarkgrey

plots.females$MEnavajowhite2

plots.females$MEblue

plots.females$MEdarkorange
```

### coral1 - inflammation
```{r}
merge.signed.females$newMEs %>% 
    as.data.frame() %>% 
    rownames_to_column("fish_id") %>% 
    dplyr::select(fish_id, MEcoral1) %>% 
    as_tibble %>% 
    left_join(x.females$samples) %>% 
    pivot_longer(names_to = "module", 
                 values_to = "ME_value", 
                 starts_with("ME")) %>% 
  dplyr::filter(group != "het_iron") %>% 
    ggplot(
      aes(x = group, y = ME_value, colour = group, fill = group)
    ) +
  geom_boxplot(
    alpha = 0.5, 
    linewidth = 2
  ) +
  scale_color_manual(
    values = c("grey60", "#46B1C9", "#231F38")
  )  +
  scale_fill_manual(
    values = c("grey60", "#46B1C9", "#231F38")
  )  +
  labs(
    title = paste0("Inflammation module"),
    subtitle = paste("Genotype: p =",                    moduleTraitPValue.signed.females["MEcoral1","genotypehom"] %>% 
                         signif(2), 
                       "\nGenotype x treatment: p = ", 
                       moduleTraitPValue.signed.females["MEcoral1","genotypehom:treatment10 Âµg Fe-citrate"] %>% signif(2)
      )
    ) +
 theme(
    legend.position = "bottom", 
    plot.background = element_blank(),
    legend.background = element_blank(),
    panel.background = element_blank(),
    strip.background = element_rect(fill = NA),
    plot.title= element_text(size = 25, face = "bold", hjust = 0.5),
    plot.subtitle= element_text(size = 15, face = "bold", hjust = 0.5),
    legend.text = element_text(size = 15, face = "bold"),
    legend.title = element_text(size = 15, face = "bold"),
    axis.text = element_text(size = 15, face = "bold"), 
    axis.title = element_text(size = 15, face = "bold"), 
    axis.title.x = element_blank(),
    strip.text = element_text(size = 15, face = "bold"), 
    axis.text.x =  element_text(size = 15, face = "bold", hjust = 0, angle = -35), 
    plot.margin = margin(r = 20)
  ) 
  
  
  cnetplot(merged.moduls.female.signed.enrichment.res$coral1)+
  theme(
    legend.position = "none"
  ) +
  ggsave(
    "output/plots4RADposter/inflammationfems_cnet.png",
     width = 14, height = 7, units = "cm", dpi = 600, scale =2.5)
```

### blue - synpatic
```{r}
merge.signed.females$newMEs %>% 
    as.data.frame() %>% 
    rownames_to_column("fish_id") %>% 
    dplyr::select(fish_id, MEblue) %>% 
    as_tibble %>% 
    left_join(x.females$samples) %>% 
    pivot_longer(names_to = "module", 
                 values_to = "ME_value", 
                 starts_with("ME")) %>% 
  dplyr::filter(group != "het_iron") %>% 
    ggplot(
      aes(x = group, y = ME_value, colour = group, fill = group)
    ) +
  geom_boxplot(
    alpha = 0.5, 
    linewidth = 2
  ) +
  scale_color_manual(
    values = c("grey60", "#46B1C9", "#231F38")
  )  +
  scale_fill_manual(
    values = c("grey60", "#46B1C9", "#231F38")
  )  +
  labs(
    title = paste0("Synaptic module"),
    subtitle = paste("Genotype: p =",                    moduleTraitPValue.signed.females["MEblue","genotypehom"] %>% 
                         signif(2), 
                       "\nGenotype x treatment: p = ", 
                       moduleTraitPValue.signed.females["MEblue","genotypehom:treatment10 Âµg Fe-citrate"] %>% signif(2)
      )
    ) +
 theme(
    legend.position = "bottom", 
    plot.background = element_blank(),
    legend.background = element_blank(),
    panel.background = element_blank(),
    strip.background = element_rect(fill = NA),
    plot.title= element_text(size = 25, face = "bold", hjust = 0.5),
    plot.subtitle= element_text(size = 15, face = "bold", hjust = 0.5),
    legend.text = element_text(size = 15, face = "bold"),
    legend.title = element_text(size = 15, face = "bold"),
    axis.text = element_text(size = 15, face = "bold"), 
    axis.title = element_text(size = 15, face = "bold"), 
    axis.title.x = element_blank(),
    strip.text = element_text(size = 15, face = "bold"), 
    axis.text.x =  element_text(size = 15, face = "bold", hjust = 0, angle = -35), 
    plot.margin = margin(r = 20)
  ) 
  
  
  cnetplot(merged.moduls.female.signed.enrichment.res$blue, 
           layout = "kk") +
  theme(
    legend.position = "none"
  ) 
  # ggsave(
  #   "output/plots4RADposter/synapticfems_cnet.png",
  #    width = 14, height = 7, units = "cm", dpi = 600, scale =2.5)
```





## males

In males, there doesnt seem to be much changes in the correlation of genotype and treatment. 

```{r}
# plot a heatmap showing the correlations
moduleTraitCor.signed.males %>%
  .[interesting.modules.males,] %>%
  as.data.frame() %>%
  dplyr::select(-1) %>%
  t %>% 
  pheatmap(
    color = colorRampPalette(rev(brewer.pal(n = 7,
                                            name = "RdBu")))(100),
     border_color = "white",
     # angle_col = 5,
     treeheight_row = 0,
     treeheight_col = 0,
     clustering_distance_cols = "correlation",
     cluster_rows = FALSE,
     number_color = "black",
     cellwidth = 25, cellheight = 25,
     fontsize = 9,
     main = "Module - trait relationships - Males",
    display_numbers = moduleTraitPValue.signed.males %>%
      .[interesting.modules.males,] %>%
      dplyr::select(-1, -module) %>%
      t %>%
      signif(1)
  )
```

## plot the module eigengenes

The eigengenes which show a significant correlation in at least one of the coefs are plotted below by genotype and treatent. The `orangered4` and `yellowgreen` modules show some suble trends towards rescue. But the `plum1` and `cyan` modules look more significantly perturbed.  

```{r}
# a function for plotting MEs
0 %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot() +
  facet_wrap(~module, nrow = 2)
```

### orangered4 module 

```{r}
ggarrange(
  merge.signed.males$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEorangered4) %>% 
  as_tibble %>% 
  left_join(x.males$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot(), 
  
  upsetplot(merged.moduls.male.signed.enrichment.res$orangered4)
)
```

### yellowgreen module

```{r}
ggarrange(
  merge.signed.males$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEyellowgreen) %>% 
  as_tibble %>% 
  left_join(x.males$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot(), 
  
  upsetplot(merged.moduls.male.signed.enrichment.res$yellowgreen)
)
```

### plum1 module - inflammation 

This supports that inflammation increased after iron supplementation in males. 
```{r}
ggarrange(
  merge.signed.males$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEplum1) %>% 
  as_tibble %>% 
  left_join(x.males$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot() + 
  labs(
    title = paste("royalblue module -", length(genesInModuleList.signed.females$royalblue), "genes"),
    subtitle = paste("Association with genotype: p =", 
                moduleTraitPValue.signed.males["MEplum1","genotypehom"] %>% signif(2))
    ) +
    scale_color_manual(
      values = c("grey30", "orange")
    ), 
  
  upsetplot(merged.moduls.male.signed.enrichment.res$plum1)
)
  # ggsave("output/plots/WGCNAmaleroylalbluemod.png", 
  #        width = 15, height = 5, units = "cm", 
  #        scale = 2,
  #        dpi = 300)
```

### cyan module

No GO terms were over-represented in this module. 
```{r}
ggarrange(
  merge.signed.males$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEcyan) %>% 
  as_tibble %>% 
  left_join(x.males$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot())
```

# module preservation
I now want to see whether any of the modules are preserved in the male and female networks To do this, I will perform module preservation analysis. 

In this analysis, the function will assess a whole bunch of different parameters. Such as connectivity (row sum of adjacency matrix, sum of connection strength to other nodes), density (mean adjacency), which is highly related to mean connectivity, and separability of modules: does the module remain distinct in the test data? This is a difficult component to deal with... Hovarth says this statistic isnt particularly meaningful. 

The function then finds the z summary, a composite of all these scores. The z summary is 

```{r}
# Form multi-set expression data:   
multiExpr <- multiData(
  female = input_mat.females, 
  male = input_mat.males 
)

#checkSets(multiExpr)

# run the module preservation calculation using the females as a ref. 
# This may take hours. 
modulepreservationres <- modulePreservation(
    multiData = multiExpr, 
    dataIsExpr = TRUE, 
    multiColor = list(
      female = merge.signed.females$colors, 
      male = merge.signed.males$colors
    ), 
    networkType = "signed", 
    verbose = 3
  )

# specify the reference and the test networks
ref=1; test = 2

# plot the module summary data
ggarrange(
modulepreservationres$preservation$Z$ref.female$inColumnsAlsoPresentIn.male %>% 
  rownames_to_column("module") %>% 
  ggplot(
    aes(x = moduleSize, y = Zsummary.pres, colour = module)  
  ) +
  geom_point() +
  geom_label_repel(
    aes(label = module), 
    data  = . %>% 
      dplyr::filter(Zsummary.pres >= 10)
    ) +
  scale_color_identity() +
  labs(
    title = "Z summary", 
    caption = "Z > 10 means higher preserved"
  ),

modulepreservationres$preservation$observed$ref.female$inColumnsAlsoPresentIn.male %>% 
   rownames_to_column("module") %>% 
  ggplot(
    aes(x = moduleSize, y = medianRank.pres, colour = module)  
  ) +
  geom_point() +
  geom_label_repel(aes(label = module)) +
  scale_color_identity() +
  labs(
    title = "Median Rank", 
    caption = "Lower median rank means more preservation"
  )
)
```


```{r}
input_mat.females[,genesInModuleList.signed.females$royalblue] %>% t %>% scale %>% plotMat()

# set the margins of the graphics window
par(mfrow = c(1, 1), mar = c(0.3, 5.5, 3, 2))
# create a heatmap whose columns correspond to the arrays and whose rows
# correspond to genes
plotMat(scale(input_mat.females[,genesInModuleList.signed.females$royalblue]),
        cex.axis = 2, nrgcols = 30, rlabels = F, rcols = whichmodule, 
    main = paste("heatmap", "module"))

```

# Export to cytoscape
```{r}
#make a lookup table for converting geneids to gene
geneid2name <- x$genes %>%
    dplyr::select(gene_id, gene_name)

# make a copy of adj.fams
mat <- adjacency.signed.females

colnames(mat) <- geneid2name$gene_name[match(colnames(mat), geneid2name$gene_id)]
rownames(mat) <- geneid2name$gene_name[match(rownames(mat), geneid2name$gene_id)]

mat[1:10,1:10]

WGCNA::exportNetworkToCytoscape(
    adjMat = mat,
    nodeFile = "output/WGCNA/female-cytoscape_adjacncy-nodes.csv",
    edgeFile = "output/WGCNA/female-cytoscape_adjacncy-edges.csv",
    nodeAttr = mergedColors.signed.females,
    weighted = TRUE
)
```

# export rest of data
```{r}

# enrichment results
tibble(module = unique(mergedColors.signed.females)) %>% 
  left_join(merged.modules.signed.enrichment.tables$females %>% bind_rows()) %>% 
  saveRDS("output/WGCNA/enrichment_table_female_GOterms.rds")

tibble(module = unique(mergedColors.signed.females)) %>% 
  left_join(merged.modules.signed.enrichment.tables$females %>% bind_rows()) %>% 
  write.csv("output/WGCNA/enrichment_table_female_GOterms.csv")

tibble(module = unique(mergedColors.signed.males)) %>% 
  left_join(merged.modules.signed.enrichment.tables$males %>% bind_rows()) %>% 
  saveRDS("output/WGCNA/enrichment_table_male_GOterms.rds")

tibble(module = unique(mergedColors.signed.males)) %>% 
  left_join(merged.modules.signed.enrichment.tables$males %>% bind_rows()) %>% 
  write.csv("output/WGCNA/enrichment_table_male_GOterms.csv")

# TOMs
# this takes a while
saveRDS(TOM.signed.females, "output/WGCNA/R_objects/TOM.signed.females.rds")
saveRDS(TOM.signed.males, "output/WGCNA/R_objects/TOM.signed.males.rds")

# adjacency matrices
# this takes a while
saveRDS(adjacency.signed.females,
        "output/WGCNA/R_objects/adjacency.signed.females.rds")
saveRDS(adjacency.signed.males,
        "output/WGCNA/R_objects/adjacency.signed.males.rds")

# modules
saveRDS(mergedColors.signed.females,
        "output/WGCNA/R_objects/mergedColors.signed.females.rds")
saveRDS(mergedColors.signed.males,
        "output/WGCNA/R_objects/mergedColors.signed.males.rds")

# module eigengenes
saveRDS(merge.signed.males,
        "output/WGCNA/R_objects/merge.signed.males.rds")
saveRDS(merge.signed.females,
        "output/WGCNA/R_objects/merge.signed.females.rds")

# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1
MEs = mergedMEs
```

# session info
```{r}
sessioninfo()
```

