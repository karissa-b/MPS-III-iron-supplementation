---
title: "WGCNA_2"
author: "Karissa Barthelson"
date: "2024-03-07"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  autodep = TRUE,
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center", 
  out.width ="75%", 
  out.height = "75%"
)
```
```{r}
library(tidyverse)
library(magrittr)
library(readxl)

# vis
library(pander)
library(kableExtra)
library(UpSetR)
library(scales)
library(pheatmap)
library(ggpubr)
library(ggrepel)
library(ggfortify)
library(ggforce)
library(RColorBrewer)
library(colorspace)
library(igraph)

# analysis
library(WGCNA)
library(topGO)
library(org.Dr.eg.db)
library(clusterProfiler)
library(msigdbr)
library(matrixStats)

theme_set(theme_classic())
options(stringsAsFactors = FALSE)
allowWGCNAThreads()  
```

# Introduction

In the previous [WGCNA analysis](WGCNA.html), I analysed all fish in the experiment together. This was overall successful, and I found modules of co-expressed genes, which were over-represented with gene ontologies meaning they have biological relevance. Some modules were significantly correlated with genotype and treatment as well. However, it was difficult to perform linear modelling when I wanted to look at module eigengenes which are associated with genotype and treatment across the sexes. I found a paper by [Sutherland et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6404618/) which performed WGCNA analysis on Brook Char (another type of fish) across sexes. They built co-expression networks for each sex, then looked for module preservation. I will try this approach here. 

# setup
## Read in data

The `DGE` object was read in, which contains the gene expression and sample info. The logCPM values for each gene were also read in which are already filtered for lowly expressed genes, are TMM & CQN normalised. I then will seperate the DGE object into two of them by sex. 
```{r}
# read in data 
x <- readRDS("data/RNAseq/R-objects/x_dgeObject_withCQNoffset.rds")

# update the group factor for this analysis
x$samples %<>% 
  mutate(group = paste0(genotype, "_", treatment2) %>% 
           as.factor())

# CQN adjusted logCPM
logCPM <- readRDS("data/RNAseq/R-objects/logCPM_CQN")

```

```{r, fig.cap="LogCPM values after TMM and CQN normalisation. All samples appear to have similar distributions"}
# plot the TMM/CQN normalised data 
logCPM %>% 
  as.data.frame() %>% 
  rownames_to_column("gene_id") %>% 
  pivot_longer(
    names_to = "sample", 
    values_to = "logCPM", 
    colnames(x)
  ) %>% 
  left_join(x$samples) %>% 
  ggplot(
    aes(x = sample, y = logCPM, 
        fill = genotype), 
    size = 1
    ) +
  geom_boxplot()+
  facet_wrap(~sex+treatment, scales = "free_x", 
             nrow = 1) +
  theme(
    axis.text.x = element_text(angle = -45, hjust = 0))
```

```{r}
# make vectors for subsetting
male.fish.ids <- x$samples %>% 
  dplyr::filter(sex == "male") %>% 
  .$fish_id

female.fish.ids <- x$samples %>% 
  dplyr::filter(sex == "female") %>% 
  .$fish_id

# subset DGEs
x.males <- x[,male.fish.ids]
x.females <- x[,female.fish.ids]

# subset logCPMs
logCPM.male <- logCPM[,male.fish.ids]
logCPM.female <- logCPM[,female.fish.ids]
```

## prepare for WGCNA

Genes that do not vary across samples are not informative in network analysis, and will increase the noise. So I will only retain the top 75% most variable genes in the datasets. Assessment of the distribution of the gene expression values before and after filtering shows no issues in any artefacts being generated. 

```{r}
# Retain genes with sufficiently high variation in expression across all samples.
# Here we define sufficiently high variation as having a standard deviation above the 25th quantile (so not in bottom 25%).
variableGenes.female <- rowSds(logCPM.female) >  quantile(rowSds(logCPM.female), 0.25)

variableGenes.male <- rowSds(logCPM.male) >  quantile(rowSds(logCPM.male), 0.25)
```

```{r}
# write a function to plot these out
plot.density.filtering = function(dge, 
                                  logCPM, 
                                  variableGenesVector, 
                                  ggtitle) {
  logCPM %>% 
  as.data.frame() %>% 
  rownames_to_column("gene_id") %>%
  pivot_longer(
    names_to = "fish_id", 
    values_to = "logCPM", 
    colnames(dge)
  ) %>% 
  left_join(dge$samples) %>% 
  ggplot(aes(x = logCPM, colour = group)) +
  geom_density() + 
  ggtitle(ggtitle)
}
```


```{r, fig.cap="Females"}
## females
ggarrange(
  plot.density.filtering(
    dge = x.females, logCPM = logCPM.female, ggtitle = "before filtering"), 
  
    plot.density.filtering(
    dge = x.females, 
    logCPM = logCPM.female %>% extract(variableGenes.female,),
    ggtitle = "After filtering"), 
  common.legend = TRUE
)
```

```{r, fig.cap="Males"}
ggarrange(
  plot.density.filtering(
    dge = x.males, logCPM = logCPM.male, ggtitle = "before filtering"), 
  
    plot.density.filtering(
    dge = x.males, 
    logCPM = logCPM.male %>% extract(variableGenes.male,),
    ggtitle = "After filtering"), 
  common.legend = TRUE
) 
```

```{r}
# peformed the filtering
logCPM.female.filtered <- logCPM.female %>% extract(variableGenes.female,)
logCPM.male.filtered <- logCPM.male %>% extract(variableGenes.male,)
```

the table below shows the number of genes retained after filtering. While the numbers of genes are the same in each sex, they are not necessarily the same genes 

```{r}
tibble(
  `filtered?` = c(
    "unfiltered", "unfiltered", 
    "filtered", "filtered" 
), 

sex = c("female", "male", "female", "male"), 

n_genes = c(
  dim(logCPM.female)[1], 
  dim(logCPM.male)[1],
  dim(logCPM.female.filtered)[1],
  dim(logCPM.male.filtered)[1]
  )
) %>% 
  pander()
```

The WGCNA pipeline is expecting an input matrix of RNAseq data (counts). Usually we need to rotate (transpose) the input data so `rows = samples` and `columns = gene counts`. So this is done here. 

```{r}
# transpose the data 
input_mat.females = t(logCPM.female.filtered)
input_mat.males = t(logCPM.male.filtered)
```

# check sample clustering

Here we use the gene expression patterns after normalisation to build 
sample dendrograms (sample tree), and check how the `traits` (e.g.
metadata) related to the sample dendrogram.

Traits uses a design matrix as described in the previous DE genes
analysis.s
```{r, fig.cap="No obvious outliers are observed here"}
# Apply hierarchial clustering to the gene exp data. 
sampleTree.females <- hclust(dist(input_mat.females), method = "complete")
sampleTree.males <- hclust(dist(input_mat.males), method = "complete")

# Using the design matrix, which contains information of samples' sex and genotype
traits.females <-  
  model.matrix(~(genotype+treatment)^2, x.females$samples) %>%
  as.data.frame

traits.males <-  
  model.matrix(~(genotype+treatment)^2, x.males$samples) %>%
  as.data.frame

# Assign each group in design matrix to a colour. 
traitColors.females <- 
  numbers2colors(traits.females, 
                 signed = FALSE, 
                 colors = c("#ffffff", "#73626E"))

traitColors.males <- 
  numbers2colors(traits.males, 
                 signed = FALSE, 
                 colors = c("#ffffff", "#73626E"))

# Plot dendrogram of clustered samples with the design matrix underneath. 

plotDendroAndColors(
  sampleTree.females, 
  traitColors.females,
  groupLabels = names(traits.females),
  main = "Females \nSample dendrogram and trait heatmap")

plotDendroAndColors(
  sampleTree.males, 
  colors = traitColors.males,
  groupLabels = names(traits.males),
  main = "Males\nSample dendrogram and trait heatmap")
```



# Network construction

## Choice of soft-thresholding power

Constructing a weighted gene network requires a soft-thresholding power β, which will be chosen based on the scale-free topology criterion described by Zhang & Horvath (2005). 
Here we perform the analysis of network topology for choosing a proper soft-threshold power.The following plots show the sufficiently high scale-free topology index (R2). Zhang and Hovarth stated in their framework ref that "we use the first parameter value where saturation is reached as long as it is above 0.8". Also, the mean connectivity should be not 0, otherwise nothing will be connected.

Also, I will need to choose between a signed or unsigned network. A good explanation of signed vs unsigned networks is described
[here](https://peterlangfelder.com/2019/05/30/signed-network-from-signed-topological-overlap/). However, essentially, in an *unsigned* network, genes are considered connected regardless of whether the correlation is positive or negative. Then in signed networks, the direction matters. I will prepare a signed network, as I think directionality is important. 

```{r}
# prepare a vector with a series of candicdate poweres
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# signed network analysis of scale-free topology
sft.females <- 
  pickSoftThreshold(
    input_mat.females, #  Input data 
    powerVector = powers, 
    networkType = "signed",
    dataIsExpr = TRUE, 
    verbose = 5
  )

sft.males <- 
  pickSoftThreshold(
    input_mat.males, #  Input data 
    powerVector = powers, 
    networkType = "signed",
    dataIsExpr = TRUE, 
    verbose = 5
  )
```

```{r}
# plot out the results
# first define the function. 
plot.powers = function(sft) {
  
  ggarrange(
     sft$fitIndices %>% 
    ggplot(
      aes(x = Power, y = -sign(slope) * SFT.R.sq)
    ) +
    geom_label(
      aes(label = Power)
    ) +
    geom_hline(
      yintercept = 0.8, 
      colour = "red") +
    annotate(
      geom = "text", 
      label = "beta = 0.8",
      colour = "red",
      x = 4, 
      y = 0.75
    ) +
    labs(
      x = "Soft Threshold (power)",
      y = "Scale Free Topology Model Fit, signed R^2",
      title = "Scale independence"
    ), 
  
  sft$fitIndices %>% 
    ggplot(
      aes(x = Power, y = mean.k.)
    ) +
    geom_label(
      aes(label = Power)
    ) +
    geom_hline(
      yintercept = 0, 
      colour = "red") +
    annotate(
      geom = "text", 
      label = "k = 0",
      colour = "red",
      x = 3, 
      y = 190
    ) +
    labs(
      x = "Soft Threshold (power)",
      y = "Mean connectivity (k)",
      title = "Mean connectivity" 
  ) 
  
)
  
}

plot.powers(sft = sft.males) 

plot.powers(sft = sft.females)
```

### define soft powers
```{r}
softpower.signed = 16
```

From the 2 graphs, I will assign the soft powers for the signed networks as `r softpower.signed`. This is the first value where the graphs plateau which is
more than 0.8.

## Co-expression adjacency

We now calculate the adjacency matrix, using the soft thresholding
powers just described. This essentially takes the gene expression data
and calculates the pairwise similarity between genes (Euclidean
distance). This similarity measure is then transformed into an adjacency
matrix by using the power function. (i.e. a = \|s\^β\|)

```{r}
adjacency.signed.females <-
  adjacency(
    input_mat.females, 
    type = "signed", 
    power = softpower.signed
    )

adjacency.signed.males <-
  adjacency(
    input_mat.males, 
    type = "signed", 
    power = softpower.signed
    )
```

## Topological Overlap Matrix (TOM)

To minimize effects of noise and spurious associations, we transform the
adjacency into Topological Overlap Matrix, and calculate the corresponding dissimilarity.

```{r}
# Turn adjacency into topological overlap
TOM.signed.males <- TOMsimilarity(adjacency.signed.males)
TOM.signed.females <- TOMsimilarity(adjacency.signed.females)

dissTOM.signed.males = 1-TOM.signed.males
dissTOM.signed.females = 1-TOM.signed.females
```

Plotting the dissimilarity of the genes in the network reveals a lot of the genes with TOM between 0.9 and 1. This means that the majority of the genes are very connected to each other.

```{r}
# We now use hierarchial clustering to produce a hierarchial clustering tree (dendrogram) of genes using TOM
geneTree.signed.males <- 
  hclust(as.dist(dissTOM.signed.males), method = "average")
geneTree.signed.females <- 
  hclust(as.dist(dissTOM.signed.females), method = "average")

par(mfrow=c(2,1))

# Plot the dendrogram
plot(geneTree.signed.males,
     xlab = "", ylab = "", 
     main = "Gene clustering on TOM-based dissimilarity\nMale network",
     labels = FALSE, hang = 0.04)

plot(geneTree.signed.females,
     xlab = "", ylab = "", 
     main = "Female network",
     labels = FALSE, hang = 0.04)
```

# Define modules

The next step is to define the modules or clusters of genes. This is done using dynamic tree cut method.

```{r}
# The authors of WGCNA suggest this minimum module size to give "relatively large modules"
minModuleSize = 30

# Module identification using dynamic tree cut. The [arameters are set according to what the WGCNA tutorial suggests. 
dynamicMods.signed.males <- 
  cutreeDynamic(dendro = geneTree.signed.males, 
                distM = dissTOM.signed.males,
                deepSplit = 2, 
                pamRespectsDendro = FALSE,
                minClusterSize = minModuleSize)

dynamicMods.signed.females <- 
  cutreeDynamic(dendro = geneTree.signed.females, 
                distM = dissTOM.signed.females,
                deepSplit = 2, 
                pamRespectsDendro = FALSE,
                minClusterSize = minModuleSize)

# give the modules a name based off baseR colours. 
dynamicColors.signed.females <- labels2colors(dynamicMods.signed.females)
dynamicColors.signed.males <- labels2colors(dynamicMods.signed.males)
```

## raw modules
```{r}
plot_n_genes_perModule = function(dynamicColors, title) {
  dynamicColors %>%
    as.data.frame() %>% 
    set_colnames("mod") %>% 
    group_by(mod) %>% 
    mutate(total = n()) %>% 
    ggplot(aes(x = reorder(mod, -total), fill = mod)) +
    geom_bar(colour= "black")  +
    theme(
      axis.text.x = element_text(
        angle = -90, hjust = 0, vjust = 0.4
      ),
      plot.title = element_text(hjust = 0.5, face = "bold"),
      legend.position = "none"
    ) +
    labs(
      title = title, 
      x = "Module", 
      y = "Number of genes"
    ) +
  scale_fill_identity() # fill the actual colours
}

plot_n_genes_perModule(dynamicColors = dynamicColors.signed.females, 
                       title = "Female modules before merging")

plot_n_genes_perModule(dynamicColors = dynamicColors.signed.males, 
                       title = "Male modules before merging")
```

The next plot shows the clustering dendrogram of genes, with dissimilarity based on topological overlap, together with assigned merged module colors. There are a lot of modules here which are all over the dendrogram. The plots i've seen previously (i.e. [here](https://www.google.com/search?q=wgcna+dendrogram&sca_esv=592686156&rlz=1C5CHFA_enAU758AU758&tbm=isch&sxsrf=AM9HkKkSBZcwsy5iPy7CeFt2oRp73UiS6A:1703121651127&source=lnms&sa=X&sqi=2&ved=2ahUKEwj675jIrp-DAxU6TGwGHfCTBwMQ_AUoAXoECAIQAw&biw=1239&bih=827&dpr=1#imgrc=FAA689FFNIDKNM)) often show at least some blocks of module colours on the dendrogram. Although this is not always the case (see [here](https://peterlangfelder.com/2018/12/30/why-wgcna-modules-dont-always-agree-with-the-dendrogram/)), as this can be a limitation of visualizing on a dendrogram.

```{r}
plotDendroAndColors(geneTree.signed.males, 
                    dynamicColors.signed.males, 
                    "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors\nsigned network"
)

plotDendroAndColors(geneTree.signed.females, 
                    dynamicColors.signed.females, 
                    "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors\nsigned network"
)
```

## merge similar modules

The Dynamic Tree Cut may identify modules whose expression profiles are very similar. It may be beneficial to merge such modules since their genes are highly co-expressed. To quantify co-expression similarity of entire modules, we calculate their eigengenes and cluster them on their correlation.

```{r}
# calculate the eigengenes of each module
MEList.signed.females <- 
  moduleEigengenes(
    expr = logCPM.female.filtered %>% t(), 
    colors = dynamicColors.signed.females,
    excludeGrey = TRUE
  )

MEList.signed.males <- 
  moduleEigengenes(
    expr = logCPM.male.filtered %>% t(), 
    colors = dynamicColors.signed.males,
    excludeGrey = TRUE
  )


# Calculate dissimilarity of module eigengenes
MEDiss.signed.females = 1-cor(MEList.signed.females$eigengenes)
MEDiss.signed.males = 1-cor(MEList.signed.males$eigengenes)


# Cluster module eigengenes
METree.signed.females = hclust(as.dist(MEDiss.signed.females), method = "average")
METree.signed.males = hclust(as.dist(MEDiss.signed.males), method = "average")

# Plot the result
sizeGrWindow(7, 6)
plot(METree.signed.females, 
     main = "Clustering of module eigengenes\n Females",
     xlab = "", sub = "")

plot(METree.signed.males, 
     main = "Clustering of module eigengenes\n Males",
     xlab = "", sub = "")

# defnine a module threshold as the same if it has more than 25% dissimilarity (i.e.. 75% similar)
MEDissThres = 0.25
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red") 
```

There appear to be plenty of modules which show similarity. Here we
define the threshold for module merging as a height \< 0.25 (as
performed by authors of WGCNA). This corresponds to correlation of 0.75,
to merge. 

```{r}
# Call an automatic merging function
merge.signed.females <- mergeCloseModules(
  t(logCPM.female.filtered), 
  dynamicColors.signed.females, 
  cutHeight = MEDissThres, 
  verbose = 3)

merge.signed.males <- mergeCloseModules(
  t(logCPM.male.filtered), 
  dynamicColors.signed.males, 
  cutHeight = MEDissThres, 
  verbose = 3)


# The merged module colors
mergedColors.signed.males = merge.signed.males$colors
mergedColors.signed.females = merge.signed.females$colors


# Table of number of modules after merging

plot_n_genes_perModule(dynamicColors = mergedColors.signed.males, 
                       title = "Males")
plot_n_genes_perModule(dynamicColors = mergedColors.signed.females, 
                       title = "females")


# Cluster module eigengenes
mergedMETree.signed.females = hclust(as.dist(MEDiss.signed.females), method = "average")

mergedMETree.signed.males = hclust(as.dist(MEDiss.signed.males), method = "average")
```

## gene tree after merging similar modules
```{r, fig.cap="female brains"}
sizeGrWindow(12, 9)
plotDendroAndColors(
  geneTree.signed.females, 
  cbind(dynamicColors.signed.females, mergedColors.signed.females),
  c("Dynamic Tree Cut", "Merged dynamic"),
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```


```{r, fig.cap="male brains"}
plotDendroAndColors(
  geneTree.signed.males, 
  cbind(dynamicColors.signed.males, mergedColors.signed.males),
  c("Dynamic Tree Cut", "Merged dynamic"),
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```

# enrichment analysis of modules

I next will perform GO enrichment analysis on the merged modules to see
if they have any biological meaning. I will do this using GO terms, as these have very specific or broad meaning. Since I am having trouble using the inbuilt functions in `WGCNA`, I will use `clusterprofiler` which allows me to perform a Fishers exact test for over representation.

```{r}
# Make a list with the gene expression by module 
colour.names.signed.males <- mergedColors.signed.males %>% 
  unique
colour.names.signed.females <- mergedColors.signed.females %>% 
  unique

genesInModuleList.signed.males <- 
 colour.names.signed.males %>% 
  sapply(function(x) {
    logCPM.male.filtered[mergedColors.signed.males==x,] %>% 
      rownames
  }, simplify = F)

genesInModuleList.signed.females <- 
 colour.names.signed.females %>% 
  sapply(function(x) {
    logCPM.female.filtered[mergedColors.signed.females==x,] %>% 
      rownames
  }, simplify = F)

```

```{r}
# perform the enrichment test
merged.moduls.male.signed.enrichment.res <- 
  genesInModuleList.signed.males %>% 
  sapply(function(y) {
      enrichGO(
        gene = y,
        universe = rownames(logCPM.male.filtered),
        OrgDb = org.Dr.eg.db,
        keyType = "ENSEMBL",
        ont = "ALL",
        pAdjustMethod = "BH",
        pvalueCutoff  = 0.01,
        qvalueCutoff  = 0.05,
        readable = TRUE)
  }, simplify = F)

merged.moduls.female.signed.enrichment.res <- 
  genesInModuleList.signed.females %>% 
  sapply(function(y) {
      enrichGO(
        gene = y,
        universe = rownames(logCPM.female.filtered),
        OrgDb = org.Dr.eg.db,
        keyType = "ENSEMBL",
        ont = "ALL",
        pAdjustMethod = "BH",
        pvalueCutoff  = 0.01,
        qvalueCutoff  = 0.05,
        readable = TRUE)
  }, simplify = F)
```

```{r}
# prepare a list with all the resultsin tibble format for ease of use. 
merged.modules.signed.enrichment.tables <- 
  list(
    females = merged.moduls.female.signed.enrichment.res %>% 
      lapply(function(x) {
        x %>% 
          as_tibble 
      }) %>% 
      imap(~ .x %>% mutate(module = .y)), # add mod name from list element name
    
    males = merged.moduls.male.signed.enrichment.res %>% 
      lapply(function(x) {
        x %>% 
          as_tibble 
      }) %>% 
  imap(~ .x %>% mutate(module = .y))
  )
```

Out of the `r length(unique(mergedColors.signed.females))` modules detected in the female modules, `r sum(sapply(merged.modules.signed.enrichment.tables$females, nrow) == 0)` do not have any GO terms significantly over-represented. 

```{r}
tibble(module = unique(mergedColors.signed.females)) %>% 
  left_join(merged.modules.signed.enrichment.tables$females %>% bind_rows()) %>% 
  ggplot(aes(y = module, x = -log10(p.adjust))) +
  geom_col(
    aes(fill = module), 
    ) +
  geom_text(aes(label = Description), 
             x = 600,
             fill = NA,
             data = . %>% 
               dplyr::distinct(module, .keep_all = TRUE) ) +
  scale_fill_identity() +
  theme_bw() +
  ggtitle("Module over-representation of GO terms in females")
```

Out of the `r length(unique(mergedColors.signed.males))` modules detected in the female modules, `r sum(sapply(merged.modules.signed.enrichment.tables$males, nrow) == 0)` do not have any GO terms significantly over-represented. 

```{r}
tibble(module = unique(mergedColors.signed.males)) %>% 
  left_join(merged.modules.signed.enrichment.tables$males %>% bind_rows()) %>% 
  ggplot(aes(y = module, x = -log10(p.adjust))) +
  geom_col(
    aes(fill = module), 
    ) +
  geom_text(aes(label = Description), 
             x = 600,
             fill = NA,
             data = . %>% 
               dplyr::distinct(module, .keep_all = TRUE) ) +
  scale_fill_identity() +
  theme_bw() +
  ggtitle("Module over-representation of GO terms in males")
```

# Relate modules to fish metadata

I now want to see which modules are related to the fish metadata (i.e. for now, genotype and treatment). For this, I will correlate the merged module eigengenes with the traits of interest using Spearman corelation. 

```{r}
# Define numbers of genes and samples
nGenes <- nrow(logCPM.male.filtered)
nSamples.males <- ncol(logCPM.male.filtered)
nSamples.females <- ncol(logCPM.female.filtered)

# correlate the module eigengenes with the design matrix
moduleTraitCor.signed.males <- 
  cor(merge.signed.males$newMEs, traits.males, use = "p", method = "spearman")

moduleTraitCor.signed.females <- 
  cor(merge.signed.females$newMEs, traits.females, use = "p", method = "spearman")


# calculate the pvals
moduleTraitPValue.signed.males <- 
  corPvalueStudent(moduleTraitCor.signed.males, nSamples.males) %>%
  as.data.frame() %>%
  mutate(module = rownames(.))

moduleTraitPValue.signed.females <- 
  corPvalueStudent(moduleTraitCor.signed.females, nSamples.females) %>%
  as.data.frame() %>%
  mutate(module = rownames(.))


# define some interesting modules for plotting. 
interesting.modules.males  <-
  moduleTraitPValue.signed.males %>%
  dplyr::filter_all(any_vars(. < 0.05)) %>%
  rownames()

interesting.modules.females  <-
  moduleTraitPValue.signed.females %>%
  dplyr::filter_all(any_vars(. < 0.05)) %>%
  rownames()
```

## Females
In females,some modules are highly correlated with genotype, and less correlated in genotype x treatment, suggesting a rescue. 
```{r}
# plot a heatmap showing the correlations
moduleTraitCor.signed.females %>%
  .[interesting.modules.females,] %>%
  as.data.frame() %>%
  dplyr::select(-1) %>%
  t %>% 
  pheatmap(
    color = colorRampPalette(rev(brewer.pal(n = 7,
                                            name = "RdBu")))(100),
     border_color = "white",
     angle_col = 315,
     treeheight_row = 0,
     treeheight_col = 0,
     clustering_distance_cols = "correlation",

     cluster_rows = FALSE,
     number_color = "black",
     cellwidth = 25, cellheight = 25,
     fontsize = 9,
     main = "Module - trait relationships - Females",
    display_numbers = moduleTraitPValue.signed.females %>%
      .[interesting.modules.females,] %>%
      dplyr::select(-1, -module) %>%
      t %>%
      signif(1)
  )
```

## plot the module eigengenes

The eigengenes which show a significant correlation in at least one of the coefs are plotted below by genotype and treatent. The `blue`, `darkgrey` and `royalblue`   modules look interesting may be at least trending towards therapeutic.  

```{r}
# a function for plotting MEs
merge.signed.females$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
   dplyr::select(fish_id, interesting.modules.females) %>% 
  as_tibble %>% 
  left_join(x.females$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot() +
  facet_wrap(~module, nrow = 2)
```

### royalblue module 
Plotting out the module eigengenes across the genotypes and treatments shows a subtle reduction in the average expression of these genes after iron treatment in the MPS IIIB fish. This module was found to be over-represented in GO terms involving the immune system. 

```{r}
ggarrange(
  merge.signed.females$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEroyalblue) %>% 
  as_tibble %>% 
  left_join(x.females$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot() +
  labs(
    title = paste("p =", 
                moduleTraitPValue.signed.females["MEroyalblue",2] %>% signif(2))), 
  
  dotplot(merged.moduls.female.signed.enrichment.res$royalblue) + 
    ggtitle("Enriched GO terms in royalblue module")
)
```

#### Gene significance and module membership

I now want to identify genes with high gene significance and module membership. 

```{r}
# Obtain the top hub gene in each module
chooseTopHubInEachModule(logCPM.female.filtered %>% t(), 
                         merge.signed.females$colors,
                        type = "signed", 
                         power = softpower.signed
                         )

# # look at the TOM Matrix for the blue module
# TOM.signed.females[merge.signed.females$colors == "royalblue",merge.signed.females$colors == "royalblue"] 

#logCPM.female.filtered
```


### dark grey module

The darkgrey module does not have any over-represented GO terms in it. 
```{r}
merge.signed.females$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEdarkgrey) %>% 
  as_tibble %>% 
  left_join(x.females$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot()
```

### blue module
This module is enriched in synaptic genes, which appear to improve after iron treatment!!! 
```{r}
ggarrange(
  merge.signed.females$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEblue) %>% 
  as_tibble %>% 
  left_join(x.females$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot() +
  ggtitle("Blue module"), 
  
  dotplot(merged.moduls.female.signed.enrichment.res$blue)
)
```


## males

In males, there doesnt seem to be much changes in the correlation of genotype and treatment. 

```{r}
# plot a heatmap showing the correlations
moduleTraitCor.signed.males %>%
  .[interesting.modules.males,] %>%
  as.data.frame() %>%
  dplyr::select(-1) %>%
  t %>% 
  pheatmap(
    color = colorRampPalette(rev(brewer.pal(n = 7,
                                            name = "RdBu")))(100),
     border_color = "white",
     angle_col = 315,
     treeheight_row = 0,
     treeheight_col = 0,
     clustering_distance_cols = "correlation",

     cluster_rows = FALSE,
     number_color = "black",
     cellwidth = 25, cellheight = 25,
     fontsize = 9,
     main = "Module - trait relationships - Females",
    display_numbers = moduleTraitPValue.signed.males %>%
      .[interesting.modules.males,] %>%
      dplyr::select(-1, -module) %>%
      t %>%
      signif(1)
  )
```

## plot the module eigengenes

The eigengenes which show a significant correlation in at least one of the coefs are plotted below by genotype and treatent. The `orangered4` and `yellowgreen` modules show some suble trends towards rescue. But the `plum1` and `cyan` modules look more significantly perturbed.  

```{r}
# a function for plotting MEs
merge.signed.males$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
   dplyr::select(fish_id, interesting.modules.males) %>% 
  as_tibble %>% 
  left_join(x.males$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot() +
  facet_wrap(~module, nrow = 2)
```

### orangered4 module 

```{r}
ggarrange(
  merge.signed.males$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEorangered4) %>% 
  as_tibble %>% 
  left_join(x.males$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot(), 
  
  barplot(merged.moduls.male.signed.enrichment.res$orangered4)
)
```

### yellowgreen module

```{r}
ggarrange(
  merge.signed.males$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEyellowgreen) %>% 
  as_tibble %>% 
  left_join(x.males$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot(), 
  
  barplot(merged.moduls.male.signed.enrichment.res$yellowgreen)
)
```

### plum1 module

This supports that inflammation increased after iron supplementation in males. 
```{r}
ggarrange(
  merge.signed.males$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEplum1) %>% 
  as_tibble %>% 
  left_join(x.males$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot(), 
  
  barplot(merged.moduls.male.signed.enrichment.res$plum1)
)
```

### cyan module

No GO terms were over-represented in this module. 
```{r}
ggarrange(
  merge.signed.males$newMEs %>% 
  as.data.frame() %>% 
  rownames_to_column("fish_id") %>% 
  dplyr::select(fish_id, MEcyan) %>% 
  as_tibble %>% 
  left_join(x.males$samples) %>% 
  pivot_longer(names_to = "module", values_to = "ME_value", starts_with("ME")) %>% 
  ggplot(aes(x = treatment, y = ME_value, colour = genotype)) +
  geom_boxplot())
```

# Module preservation between sexes
